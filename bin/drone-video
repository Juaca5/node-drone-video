#!/usr/bin/env node

/**
 * Module dependencies.
 */

var fs = require('fs');
var net = require('net');
var path = require('path');
var draw = require('../lib/draw');
var arDrone = require('ar-drone');
var strftime = require('strftime');
var program = require('commander');
var spawn = require('child_process').spawn;
var debug = require('debug')('drone-joystick');
var PaVEParser = require('ar-drone/lib/video/PaVEParser');

/**
 * Do a clean shutdown upon Ctrl+C.
 */

process.on('SIGINT', shutdown);
function shutdown () {
  console.log('\nshutting down...');

  // XXX: wtf, why doesn't node-ar-drone do this!!?!!
  clearInterval(client._interval);
  clearTimeout(client._udpNavdatasStream._timer);
  client._udpControl.close();
  client._udpNavdatasStream.destroy();

  // close the socket
  socket.destroy();

  videoEncoder.stdin.end();
}

/**
 * Output dir format.
 */

var format = 'drone-video-%Y%m%d-%H%M%S';

/**
 * Ensure output directory exists.
 * TODO: use node-mkdirp here...
 */

var dirname = strftime.strftimeUTC(format, new Date());
fs.mkdirSync(dirname);

/**
 * The most recent navigation data from the drone.
 * Used in the metadata video stream image generation.
 */

var navdata;

/**
 * Create client connection to the AR.Drone.
 */

var ip = process.argv[2] || '192.168.1.1';
var client  = arDrone.createClient({ ip: ip });
client.config('general:navdata_demo', 'TRUE');
//console.log('Connecting to drone at %j', ip);

client.on('navdata', function (data) {
  //console.log(JSON.stringify(data));
  navdata = data;
});

/**
 * Connect to drone's video stream port.
 */

var port = 5555;
var socket = net.connect({ host: ip, port: port });

socket.on('connect', function () {
  console.error('connected to drone video');
});

socket.on('error', function (err) {
  console.error('socket "error" event:', err.stack);
  shutdown();
});

var parser = new PaVEParser();
parser.on('data', function (frame) {
  startNavdata();
  debug('PaVEParser "frame"', frame);

  // write to the h264 video file and the mp4 encoder
  videoH264.write(frame.payload);
  videoEncoder.stdin.write(frame.payload);
});
socket.pipe(parser);

/**
 * Save the raw PaVE video stream untouched as "video.raw".
 */

var videoRaw = fs.createWriteStream(path.resolve(dirname, 'video.PaVE'));
socket.pipe(videoRaw);

/**
 * Save the parsed h264 stream as "video.h264".
 * See the `parser` "data" event.
 */

var videoH264 = fs.createWriteStream(path.resolve(dirname, 'video.h264'));

/**
 * Encode the "video.m4v" file.
 * See the `parser` "data" event.
 *
 * See: https://gist.github.com/4403443
 */

var videoEncoderStderr = 2;
var videoEncoder = spawn('ffmpeg', [
    '-f', 'h264',
    '-analyzeduration', '0',
    '-i', '-',
    '-an',
    path.resolve(dirname, 'video.m4v')
  ],
  { stdio: [ -1, -1, videoEncoderStderr ] }
);

/**
 * Called once the first PaVE frame has been parsed.
 */

var navdataStarted = false;
function startNavdata () {
  if (navdataStarted) return;
  navdataStarted = true;
}
